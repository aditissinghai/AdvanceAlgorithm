package AshtonAndSting;

import java.util.*;

public class AshtonAndString {
    static List<Character> ans = new ArrayList<>();
    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);
        int testCases = sc.nextInt();

        for(int i = 0; i < testCases; i++) {
           String s = sc.next();
           int k = sc.nextInt();
           ans.add(findKthCharacter(s,k));
        }

    }

    private static char findKthCharacter(String s, int k) {
        SortedSet<Substring> suffixes = new TreeSet<>();

        for(int j = 0; j < s.length(); j++) {
            suffixes.add(Substring.suffix(s, j));
        }

        int h = 0;
        int count = 0;

        Substring curr = Substring.of(s, 0, 0);

        for (Iterator<Substring> it = suffixes.iterator(); it.hasNext(); h = 0) {
            CharSequence prev = curr;
            curr = it.next();

            // Find the LCP count
            while (h < prev.length() && h < curr.length() && prev.charAt(h) == curr.charAt(h)) {
                h++;
            }

            // The suffix i will produce suffix[i].length - lcp substrings
            // because the common prefixes will have been generated by the
            // previous suffix.

            for (int x = 1, newSubs = curr.length - h; x <= newSubs; x++) {
                count += h + x;
                if (count >= k) {
                    return curr.subSequence(0, h + x).charAt(k - (count - h - x) - 1);
                }
            }
        }
        return 0;

    }

    private static class Substring implements CharSequence, Comparable<CharSequence> {
        private final String origin;
        private final int start;
        private final int length;

        private static Substring suffix(String origin, int start) {
            return new Substring(origin, start, origin.length());
        }

        private static Substring of(String origin, int start, int end) {
            return new Substring(origin, start, end);
        }

        private Substring(String origin, int start, int end) {
            this.origin = origin;
            this.start = start;
            this.length = end - start;
        }

        @Override
        public int length() {
            return length;
        }

        @Override
        public char charAt(int index) {
            return origin.charAt(start + index);
        }

        @Override
        public CharSequence subSequence(int start, int end) {
            return Substring.of(origin, this.start + start, this.start + end);

        }

        @Override
        public int compareTo(CharSequence other) {
            int len1 = length;
            int len2 = other.length();
            for (int i = 0; i < len1 && i < len2; i++) {
                int d = charAt(i) - other.charAt(i);
                if (d != 0) {
                    return d;
                }
            }
            return len1 - len2;
        }

        @Override
        public String toString() {
            return origin.substring(start, start + length);
        }
    }
}


